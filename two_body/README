
Author: 		Thorsten Tepper Garcia

Last modified:	06/07/2019


# BACKGROUND

The 3D equations of motion of two bodies of mass M1 and M2 orbiting around each
others potential are:

	dr1dt = v1
	dv1dt = - Grad Phi2

	dr2dt = v2
	dv2dt = - Grad Phi1

where,

	r := position vector of body 1 or 2
	v := velocity vector of body 1 or 2
	Grad := gradient operator (nabla)
	Phi(r) = := grav. potential of body 1 or 2

Here, we consider the case where body is possibly an extended object of 'total' mass M1,
represented by an arbitrary, static potential Phi1, and a point-like body 2 of mass M2
described by a Kepler potential (i.e. Phi1 = - G M2 / r). The latter assumption may be
relaxed in future versions of the code. Note that the 'total' mass M1 may be subject to
definition, e.g. in the case of a NFW potential for which the mass diverges with radius.

Both Phi1 and Phi2 are assumed to be central potentials that depend on the distance
bwetween the bodies only.

Even though the equation of motion is of second order (m=2) in dt,
due to its 3D vector nature, it is equivalent to a system of six
first order ODEs, for each body. Thus, the rank of the system is determined
by the order m and the dimensionality of the system D=3 as 2 * m * D = 12 in
this case.

Thus, the above vectorial equations can be written down as a system of 12
coupled ordinary differential equations of first order in dt:

	dx1dt = vx1
	dy1dt = vy1
	dz1dt = vz1
	dvx1dt = - Grad_x Phi2(|r12|)
	dvy1dt = - Grad_y Phi2(|r12|)
	dvz1dt = - Grad_z Phi2(|r12|)

	dx2dt = vx2
	dy2dt = vy2
	dz2dt = vz2
	dvx2dt = - Grad_x Phi1(|r12|)
	dvy2dt = - Grad_y Phi1(|r12|)
	dvz2dt = - Grad_z Phi1(|r12|)

Here, r12 = r1 - r2. Note that the force is radial and directed towards
the centre of the potential at all times, by assumption.

Note that a 2D system can be simulated equally well with this code by simply
setting all z-components to 0 initially.

Currently, only a number of spherically symmetric potentials are implemented.
See Section INPUT below.


# TIME INTEGRATION

The system of equations is numerically integrated using a 2nd order
leapfrog (kick-drift-kick) method (see https://en.wikipedia.org/wiki/Leapfrog_integration).
This scheme is symplectic and thus features desired properties such as time
reversibility, conservation of the relative total energy to any desired
accuracy -- even over significant integration times --, if the time step is
chosen small enough, and conservation of the specific angular momentum
generally to machine precision.

Beware that the scheme may lead to orbit precession if the integration step is
not small enough. As a general rule of thumb, the time step delta_t should
satisfy:

	delta_t < T / sqrt(2) pi ~ 0.225 T,

where T is the (shortest) period of the system (see
https://en.wikipedia.org/wiki/Energy_drift).

Also, orbit precession may naturally result from central potentials other than
point-like masses (Bertrand's Theorem; https://en.wikipedia.org/wiki/Bertrand%27s_theorem)
and it thus does not necessarily indicate an error in the integration scheme (see
Section 'IMPORTANT REMARKS' below).


# SPATIAL DERIVATIVES

A number of first order, partial, spatial derivatives are required when calculating
the force corresponding to a given potential. Two methods are implemented here:

1) A central finite difference scheme of orders 2 and 4;

2) A forward finite difference scheme of orders 2 and 3;

(see https://en.wikipedia.org/wiki/Finite_difference_coefficient).

Method 1 is preferred (and is the default), in particular because it leads to a
better conservation of angular momentum for extrem potentials such as a
point-like mass potential. Note that using a different scheme requires
to change the invoked scheme explicitly in the calculation of the accelerations.

An example on how to invoke the differentiation routines is as follows:

1) To calculate the first partial derivative of f with respect to x (var=0) at
point r = [x,y,z], using a CFD scheme of order 4 with an integration step 1.e-3
to achieve a precision of order (1.e-3)^4 use:

	fwd_diff_first(*r, var = 0, func = f, delta_x = 1.e-3, order = 4)

2) To calculate the first partial derivative of f with respect to y (var=1) at
point r = [x,y,z], using a FFD scheme of order 3 with an integration step 1.e-4
to achieve a precision of order (1.e-4)^3 use:

	fwd_diff_first(*r, var = 1, func = f, delta_x = 1.e-4, order = 3)


# UNITS

This code is intended mainly for astrophysical applications. Therefore, the
following units are adopted:

	Gravitational constant:	4.301E-06 kpc km^2 / Msun s^2
	Mass unit:				1.000 solMass = 1.988475E+33 g
	Length unit:			1.000 kpc = 3.085678E+21 cm
	Velocity unit:			1.000 km / s = 1.000000E+05 cm / s
	Time unit:				0.978 Gyr = 3.085678E+16 s

Note that the conversion factor for the time parameter is fixed by the others.
The choice of units for G is convenient, since any given potential (or specific
potential energy) automatically has units of (km/s)^2, i.e. identical to the
specific kinetic energy.


# REQUIRED / OPTIONAL PACKAGES

	- python 3.X
	- astropy for python 3.X
	- gnuplot 5+ [optional for visualisation]


# INSTALLATION

	If a working copy of python 3.X and of astropy for python 3.X is already
	installed, simply clone the repository.


# RUN

The code can be run directly from command line via:

	shell> ./two_body_orbit.py <input parameter file>

using the prededfined python interpreter given in the first line,
or:

	shell> python3.X two_body_orbit.py <input parameter file>

using an alternative python interpreter. Note that a python version 3.X is
required.


# INPUT

The input of this program consists of a python (i.e. filename.py) input
parameter file which must contain as a minimum a the masses, and the inital
state vectors, i.e. the initial position r0 and velocities v0 for each body.

The initial and final times, as well as the timestep for the integration of
the orbit can (and preferentially should) be specified. These default to 0.,
10., and 1.e-4, in time units (see Section UNITS).

In addition to the total mass, the potential for each body may be specified.
Currently, only a number of spherically symmetric potentials are implemented:

- Kepler (or point-like) potential

- Plummer (1911) potential (see https://en.wikipedia.org/wiki/Plummer_model)

- Hernquist (1990) potential (see http://adsabs.harvard.edu/abs/1990ApJ...356..359H)

- Navarro, Frenk, and White (1997) potential (see https://en.wikipedia.org/wiki/Navarro–Frenk–White_profile)

If not specified, the potential defaults to the Kepler potential.
Potentials other than the Kepler potential require the value of an additional
parameter, i.e. the scale radius.
Note that the mass of the NFW profile diverges with radius. Therefore, for
this particular model instead of the total mass, it is necessary to specify
the central density of the body, in addition the value of the concentration,
as well as its extension (typically the virial radius) from which the total mass
is calculated.

Note that providing the state vectos r0 and v0 for each body is the preferred
method to specify the initial conditions of the system. However, some methods
are available to impose certain conditions on the orbit, e.g. a circular orbit
*within* the input parameter file.

The corresponding orbital parameters (e.g. eccentricity, orbital period,
etc.) are then calculated from these at runtime and written to stodut.

The parameter file needs to be present in the directory 'init'. There, a few
example parameter files are provided, for guidance.


# OUTPUT

The output of the code consists of an ascii table redirected to the
directory './output' named after the input parameter file and appended
by the substring "_out.dat". If the directory 'output' does not exist,
it needs to be created by hand.

The table consists of a total of 26 columns. The first 16 contain, in that
order, the time, the specific relative angular momentum, the relative potential
energy, the relative kinetic energy, and (x,vx,y,vy,z,vz) for each of the
bodies. The next 8 columnns contain (x',vx',y',vy') for each of the
bodies, where the primed coordinates and velocities correspond to the coordinates
and velocities on the orbital plane. In other words, these coordinates represent a
rotated version of the intrinsic orbit such that the relative angular momentum
of the system aligns with the z-axis. If the intrinsic orbit has this property,
the primed and unprimed coordinates are identical. Note that the primed z
coordinates are ignored, because they all vanish by definition. The last two
columns contain the (x,y) coordinates of the analytic solution of the problem,
using the orbital parameters self-consistently calculated within the code.
The latter can be directly compared to the set of primed coordinates as a check
of the numerical result against the expected analytic solution, keeping in
mind that for non-Keplerian potentials the analytic solution merely corresponds
to an osculating orbit consistent with the initial conditions.


# VISUALISATION

A simple visualisation of the evolution of the system can be obtained
using the gnuplot script plot_two_body_orbit.gp provided with the code's
distribution.

This script can be run:

1) directly from a terminal via:

	shell> gnuplot plot_two_body_orbit.gp

or

2) within gnuplot via:

	gnuplot> load 'plot_two_body_orbit.gp'

The script provides both a full 3D view of the system, or alternatively,
a 2D projection along one of the principal axis of a standard Cartesian
reference frame. In addition, the code always provides a 2D view of
the system's evolution on the orbital plane. Hereby, a direct comparison
to the analytic result for given values of the semi-latus rectum, the
eccentricity, and the true anomaly offset (or apsidal angle) is readily
implemented.

If run from a terminal, the script accepts a number of input arguments,
all of which are set to reasonable defaults, the obvious exception being
the data file. Other important parameters are the time step, the time
output frequency, and the physical units, all of which are printed to
stdout by the python code at runtime.

Please consult the script's header for additional information on these
input arguments and their default values.


# IMPORTANT REMARKS

1) The conserved quantities are:

- relative specific angular momentum;
	  
- relative specific total (potential + kinetic) energy.

The individual energies and angular momenta need not necessarily
be conserved (?). The error in the conservation of angular momentum
is generally orders of magnitude smaller than the error in the conservation
of energy (why?).

Also, the spatial step and the order of accuracy used when calculating
numerical derivatives of the potential affect the conservation of angular
momentum, but not the conservation of energy (which seems to depend on the
time integration scheme only; why?).


2) Only a central, Kepler (i.e. point-mass) potential yields conic
orbits; in particular, if the eccentricity is less than unity, it leads
to *closed* orbits. In this case, the orbit can be described by a
unique set of orbital parameters (eccentricity, semi-major axis, period,
etc.) The code calculates a range of orbital parameters at runtime and
prints them to stdout.


3) Extended, spherically symmetric bodies yield gravitational forces as
though their masses were concentrated at their respective centres (Newton's
shell theorem; https://en.wikipedia.org/wiki/Shell_theorem). This implies
that the gravitational force between an extended body and a point-like mass
in principle behaves with their relative distance d as 1/d^2. This is, however,
misleading, as the the mass of the extended body `felt' by the point-like body
depends on their relative position, and can therefore be considered as variable
along the point-like body's orbit. In other words, the changing mass introduces a
dependence of distance into the expression for the gravitational force that
breaks the 1/d^2 dependence. Thus, by virtue of Bertrand's theorem
(https://en.wikipedia.org/wiki/Bertrand%27s_theorem), extended central bodies
never lead to closed orbits, not even in the case that the initial conditions
imply e < 1. The orbital parameters set by the initial conditions correspond,
at best, to *osculating* parameters in this case. The same is true for non-spherically
symmetric potentials.


